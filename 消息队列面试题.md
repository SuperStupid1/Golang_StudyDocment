# 消息队列面试题

## 题目 1：消息队列的核心作用是什么？主要解决哪些问题？

**答案**：
消息队列(MQ)的核心作用是实现系统间的异步通信和解耦，主要解决以下问题：

1. **系统解耦**：
   - 生产者和消费者无需相互感知
   - 系统间通过消息协议交互而非直接调用

2. **异步处理**：
   - 非关键路径操作异步化
   - 提高主流程响应速度

3. **流量削峰**：
   - 缓冲突发流量
   - 避免系统被压垮

4. **最终一致性**：
   - 分布式事务场景
   - 通过消息表+定时任务实现

5. **日志收集**：
   - 大数据场景下的日志聚合
   - 实时/离线分析

## 题目 2：对比RabbitMQ和Kafka的架构设计差异

**答案**：

| 特性                | RabbitMQ                          | Kafka                             |
|---------------------|-----------------------------------|-----------------------------------|
| 设计理念            | 企业级消息代理                    | 分布式流处理平台                  |
| 消息模型            | Exchange-Queue-Consumer           | Topic-Partition-ConsumerGroup     |
| 消息存储            | 内存/磁盘(可选)                  | 磁盘持久化                        |
| 吞吐量              | 万级                              | 百万级                            |
| 延迟                | 微秒级                            | 毫秒级                            |
| 消息顺序            | 单个队列保证                      | 分区内保证                        |
| 消息回溯            | 不支持                            | 支持                              |
| 协议支持            | AMQP/MQTT/STOMP等                 | 自定义协议                        |

**选型建议**：
- RabbitMQ：业务消息、RPC调用、需要灵活路由的场景
- Kafka：日志收集、大数据管道、高吞吐量场景

## 题目 3：如何保证消息的可靠投递？

**答案**：
完整的可靠投递方案需要从三个环节保障：

1. **生产者可靠性**：
   - 事务消息（性能较差）
   - 确认机制（ACK）
   - 消息落库+定时任务补偿

2. **Broker可靠性**：
   - 集群部署（镜像队列/分区副本）
   - 持久化配置
   - 磁盘RAID

3. **消费者可靠性**：
   - 手动ACK
   - 消费幂等处理
   - 死信队列+告警

**RabbitMQ示例代码**：
```go
// 生产者确认模式
ch.Confirm(false)
ch.PublishWithContext(
    ctx,
    "exchange",
    "routingKey",
    false,
    false,
    amqp.Publishing{
        DeliveryMode: amqp.Persistent,
        Body:         []byte("payload"),
    },
)
confirmed := ch.WaitForConfirms(5 * time.Second)

// 消费者手动ACK
delivery, ok := <-msgs
if ok {
    // 处理消息
    delivery.Ack(false)
}
```