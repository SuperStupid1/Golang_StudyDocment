# Go中的闭包

在 Go 语言中，**闭包（Closure）** 是一个非常强大且常用的语言特性。它指的是：**函数可以访问并操作其定义时所处的词法作用域中的变量，即使该函数在其外部被调用。**

---

## 📌 一、什么是闭包？

简单来说：

> **闭包 = 函数 + 引用环境**

Go 支持匿名函数，并且这些匿名函数可以访问其外部作用域中的变量，这就构成了闭包。

---

## 🧪 二、闭包示例

### 示例 1：基本闭包

```go
func outer() func() {
    x := 10
    return func() {
        fmt.Println(x)
    }
}

func main() {
    f := outer()
    f() // 输出 10
}
```

- `outer` 返回了一个匿名函数。
- 这个匿名函数“捕获”了变量 `x`，即使 `outer` 已经返回，`x` 依然存在。
- 这就是闭包的行为。

---

### 示例 2：多个闭包共享变量

```go
func counter() (func(), func()) {
    count := 0
    inc := func() {
        count++
        fmt.Println("Increment:", count)
    }
    dec := func() {
        count--
        fmt.Println("Decrement:", count)
    }
    return inc, dec
}

func main() {
    a, b := counter()
    a() // Increment: 1
    a() // Increment: 2
    b() // Decrement: 1
}
```

- `inc` 和 `dec` 都引用了同一个 `count` 变量。
- 它们共享这个变量的状态 —— 这也是闭包的典型特征。

---

## 🔁 三、闭包与循环变量陷阱 ⚠️

这是一个常见的误区！

### 错误写法：

```go
funcs := make([]func(), 3)

for i := 0; i < 3; i++ {
    funcs[i] = func() {
        fmt.Println(i)
    }
}

for _, f := range funcs {
    f()
}
```

输出可能是：

```
3
3
3
```

### 原因：

所有闭包都**引用了同一个变量 `i`**，而不是复制它的值。当闭包执行时，循环已经结束，`i` 的值已经是 3。

---

### 正确做法：

#### 方法 1：将变量作为参数传入闭包

```go
for i := 0; i < 3; i++ {
    funcs[i] = func(i int) {
        fmt.Println(i)
    }
}
```

或者：

```go
for i := 0; i < 3; i++ {
    v := i
    funcs[i] = func() {
        fmt.Println(v)
    }
}
```

这样每个闭包就拥有了自己的副本。

---

## ✅ 四、闭包的作用场景

闭包在 Go 中非常实用，常见用途包括：

| 场景     | 描述                                              |
| -------- | ------------------------------------------------- |
| 封装状态 | 实现类似“对象”的行为，比如计数器、缓存等          |
| 延迟计算 | 结合 `defer` 使用，延迟执行某些逻辑               |
| 函数工厂 | 动态生成函数，例如根据参数生成不同功能的函数      |
| 并发安全 | 搭配 `sync.WaitGroup` 或 `goroutine` 实现并发控制 |
| 路由处理 | 在 Web 框架中用于注册中间件或路由处理函数         |

---

## 🧠 五、闭包的性能问题

闭包会持有对外部变量的引用，可能导致：

- **内存泄漏风险**：如果闭包长时间存活，会导致其引用的变量无法被垃圾回收。
- **意外副作用**：多个闭包共享变量时，可能引发并发修改错误。

建议：
- 明确变量生命周期。
- 对于大结构体或频繁使用的资源，尽量使用指针避免拷贝。
- 注意并发安全问题（如使用锁）。

---

## 📚 六、总结

| 特性           | 说明                                         |
| -------------- | -------------------------------------------- |
| 闭包本质       | 函数 + 外部变量引用                          |
| 是否持有变量   | 是，直到闭包不再被引用                       |
| 是否会发生拷贝 | 不会自动拷贝，但你可以手动拷贝来避免共享问题 |
| 是否适用于并发 | 是，但要注意同步和竞态条件                   |

